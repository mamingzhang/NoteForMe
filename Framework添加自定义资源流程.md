#Framework添加自定义资源流程（Android5.1）
***

1. 在framework/base/core/res的同级目录增加custom-res目录，拷贝res目录下的Android.mk和AndroidManifest.xml并且做修改，目录结构如下:  

	 res  
	 Android.mk  
	 AndroidManifest.xml  
	    
	 
2. Android.mk文件内容如下:  

	```  
	LOCAL_PATH := $(call my-dir)  
	include $(CLEAR_VARS)

	CUSTOM_LOCAL_NO_STANDARD_LIBRARIES := true
	LOCAL_PACKAGE_NAME := custom-res  
	LOCAL_CERTIFICATE := platform  
	
	# Tell aapt to create "extending (non-application)" resource IDs,
	# since these resources will be used by many apps.  
	
	LOCAL_AAPT_FLAGS := -x 3

	LOCAL_MODULE_TAGS := optional

	# Install this alongside the libraries.  
	LOCAL_MODULE_PATH := $(TARGET_OUT_JAVA_LIBRARIES)

	# Create package-export.apk, which other packages can use to get
	# PRODUCT-agnostic resource data like IDs and type definitions.  
	LOCAL_EXPORT_PACKAGE_RESOURCES := true

	#Set LOCAL_CUSTOM_RES as true  
	LOCAL_CUSTOM_RES := true

	# Include resources generated by system RenderScript files.
	#framework_GENERATED_SOURCE_DIR := $(call intermediates-dir-for,JAVA_LIBRARIES,framework,,COMMON)/src
	#framework_RenderScript_STAMP_FILE := $(framework_GENERATED_SOURCE_DIR)/RenderScript.stamp
	#LOCAL_RESOURCE_DIR := $(framework_GENERATED_SOURCE_DIR)/renderscript/res $(LOCAL_PATH)/res

	include $(BUILD_PACKAGE)

	# Make sure the system .rs files get compiled before building the package-export.apk.
	# $(resource_export_package): $(framework_RenderScript_STAMP_FILE)

	# define a global intermediate target tcustomhat other module may depend on.
	.PHONY: custom-res-package-target
	custom-res-package-target: $(LOCAL_BUILT_MODULE)    
	```
3. AndroidManifest.xml内容如下：
	  
	```  
	<?xml version="1.0" encoding="utf-8"?>
	<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    	package="com.custom" coreApp="true"  
    	android:sharedUserId="android.uid.system"
    	android:sharedUserLabel="@null">

    	<application android:process="system"
            android:persistent="true"
            android:hasCode="false"
            android:label="@null"
            android:allowClearUserData="false"
            android:backupAgent="com.android.server.backup.SystemBackupAgent"
            android:killAfterRestore="false"
            android:icon="@null"
            android:supportsRtl="true">

    </application>

	</manifest>
	```
4. 修改framework/base下的Android.mk文件如下：  
	  
	```  
	# add custom-res
	custom_res_source_path := APPS/custom-res_intermediates/src
	```  
	  
	```  
	LOCAL_INTERMEDIATE_SOURCES := \
              $(framework_res_source_path)/android/R.java \
              $(framework_res_source_path)/android/Manifest.java \
              $(framework_res_source_path)/com/android/internal/R.java \
              $(custom_res_source_path)/com/custom/R.java  
    ```  
      
    ```  
    custom_res_R_stamp := \
    $(call intermediates-dir-for,APPS,custom-res,,COMMON)/src/R.stamp
	$(full_classes_compiled_jar): $(framework_res_R_stamp) $(custom_res_R_stamp)

	#$(framework_module): | $(dir $(framework_module))framework-res.apk
	$(framework_module): | $(dir $(dir $(framework_module))custom-		res.apk)framework-res.apk  
	```  
	
5. 修改base/core下的package_internal，增加编译依赖关系，增加配置如下：
	* 找到resource_export_package定义，在其后面增加如下配置  
	
	```  
	# change begin: ensure framework-res is built before building custom-res
	ifeq ($(LOCAL_CUSTOM_RES), true)
		$(resource_export_package): $(call intermediates-dir-for,APPS,framework-res,,COMMON)/src/R.stamp
	endif
	#change end: ensure framework-res is built before building custom-res  
	```  
	  
	* 找到all_library_res_package_export_deps定义，在后面增加配置如下：  
	
	```  
	#change begin: ensure custom-res is linked as dependency
	ifeq ($(LOCAL_CUSTOM_RES), true)
    	custom_res_package_export :=
    	custom_res_package_export_deps :=
	else
    	custom_res_package_export := \ $(call intermediates-dir-for,APPS, custom-res,,COMMON)/package-export.apk
    	custom_res_package_export_deps := \ $(dir $(custom_res_package_export))src/R.stamp
	endif
	#change end  
	```  
	  
6. 修改buid/core/base_rules.mk文件，修改如下逻辑，主要用于将生成的custom-res直接放在system/framework目录下，如不增加，则会在system/framework/custom-res/目录，多一级目录结构  
  
  ```  
  ifneq (true,$(LOCAL_UNINSTALLABLE_MODULE))
  # Apk and its attachments reside in its own subdir.
  ifeq ($(LOCAL_MODULE_CLASS),APPS)
  		# framework-res.apk doesn't like the additional layer.
  		ifneq ($(LOCAL_NO_STANDARD_LIBRARIES),true)
    		ifneq ($(CUSTOM_LOCAL_NO_STANDARD_LIBRARIES),true)
        		my_module_path := $(my_module_path)/$(LOCAL_MODULE)
    		endif
  		endif
  		endif
  		LOCAL_INSTALLED_MODULE := $(my_module_path)/$(my_installed_module_stem)
	endif  
	```  

7. 修改buid/core/clear_vars.mk，增加如下定义  
  
  	```  
  	LOCAL_CUSTOM_RES :=  
  	```  
  	 
8. 修改frameworks/base/libs/utils/AssertManage.cpp，加载自定义资源包custom-res.apk
	* 找到static const char* kSystemAssets = "framework/framework-res.apk"，下方添加代码如下：  
	  
	```  
	static const char* kCustomAssets = "framework/custom-res.apk"  
	```
	* addDefaultAssets 函数修改为:  
	  
	```  
	bool AssetManager::addDefaultAssets()
	{
    	const char* root = getenv("ANDROID_ROOT");
    	LOG_ALWAYS_FATAL_IF(root == NULL, "ANDROID_ROOT not set");

    	String8 path(root);
    	path.appendPath(kSystemAssets);

    	if(!addAssetPath(path, NULL)) {
        	return false;
    	}

    	String8 pathCustom(root);
    	pathCustom.appendPath(kCustomAssets);
    	return addAssetPath(pathCustom, NULL);
	}  
	```  
	
9. 修改frameworks/base/services/java/com/android/server/PackageManagerService.java  
	  
	```  
	// Gross hack for now: we know this file doesn't contain any
   // code, so don't dexopt it to avoid the resulting log spew.
   alreadyDexOpted.add(frameworkDir.getPath() + "/framework-res.apk");

   alreadyDexOpted.add(frameworkDir.getPath() + "/custom-res.apk");  
   ```  
   
10. 修改ResourceTypes.cpp，主要是修改资源映射表  

	* 注意这一行添加的数字需要与前面的标记为符合，例如LOCAL_AAPT_FLAGS := -x 3
	  
	```  
	#define SYS_SZJY_PACKAGE_ID  0x03  
	```  
	
	* 找到对应代码块做修改  
	  
	```  
	DynamicRefTable::DynamicRefTable(uint8_t packageId): mAssignedPackageId(packageId)
	{
    	memset(mLookupTable, 0, sizeof(mLookupTable));

    	// Reserved package ids
    	mLookupTable[APP_PACKAGE_ID] = APP_PACKAGE_ID;
    	mLookupTable[SYS_PACKAGE_ID] = SYS_PACKAGE_ID;
   		mLookupTable[SYS_SZJY_PACKAGE_ID] = SYS_SZJY_PACKAGE_ID;
	}  
	```  
	  
	```  
	if (packageId != APP_PACKAGE_ID && packageId != SYS_PACKAGE_ID && packageId != SYS_SZJY_PACKAGE_ID) {
        outValue->dataType = Res_value::TYPE_DYNAMIC_REFERENCE;
    }  
    ```  
      
    ```  
    else if (packageId == APP_PACKAGE_ID || packageId == SYS_PACKAGE_ID || packageId == SYS_SZJY_PACKAGE_ID) 	{
        // We accept packageId's generated as 0x01 in order to support
        // building the android system resources
        outValue->data = rid;
        return true;
    }  
    ```  
    
11. 修改aapt，对应custom-res编译脚本中的LOCAL_AAPT_FLAGS，不然资源无法对应
	  
	 * 修改tools/aapt/Bundle.h  
	   
	 ```  
	  mUpdate(false), mExtending(false), mExtendedPackageId(0),  
	 
	  int getExtendedPackageId(void) const { return mExtendedPackageId; }
     void setExtendedPackageId(int val) { mExtendedPackageId = val; }  
    
     bool        mExtending;
     int         mExtendedPackageId;  
       
	 ```
	 
	 * 修改tools/aapt/Main.cpp  
	   
	 ```  
	 	#include <ctype.h>
	 
	 	fprintf(stderr,
        	" %s p[ackage] [-d][-f][-m][-u][-v][-x[ extending-resource-id]][-z][-M AndroidManifest.xml] \\\n"  
    
    	"   -x  either create or assign (if specified) extending (non-application) resource IDs\n"  
    
    	case 'x':
           bundle.setExtending(true);
           argc--;
           argv++;
           if (!argc || !isdigit(argv[0][0])) {
                argc++;
                argv--;
           } else {
                bundle.setExtendedPackageId(atoi(argv[0]));
           }
           break;  
    ```  
    
    * 修改tools/aapt/Resources.cpp  
      
    ```  
    int extendedPackageId = bundle->getExtendedPackageId();
    ResourceTable table(bundle, String16(assets->getPackage()), packageType, extendedPackageId);
    err = table.addIncludedResources(bundle, assets);  
    ```  
    
    * 修改tools/aapt/ResouceTable.h
      
    ```  
    ResourceTable(Bundle* bundle, const String16& assetsPackage, PackageType type,
                    ssize_t pkgIdOverride);  
    ```  
    
    * 修改tools/aapt/ResouceTable.cpp
      
    ```  
    ResourceTable::ResourceTable(Bundle* bundle, const String16& assetsPackage, ResourceTable::PackageType 	 	type, ssize_t pkgIdOverride)
    	: mAssetsPackage(assetsPackage)
    	, mPackageType(type)
    	, mTypeIdOffset(0)
    	, mNumLocal(0)
    	, mBundle(bundle)
    
    if (pkgIdOverride != 0) {
        packageId = pkgIdOverride;
    }

    sp<Package> package = new Package(mAssetsPackage, packageId);
    mPackages.add(assetsPackage, package);
    mOrderedPackages.add(package);  
    ```

	